<!DOCTYPE html>
<!-- saved from url=(0093)https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/">
        <link rel="shortcut icon" href="https://learnopengl-cn.github.io/img/favicon.ico">

	<title>阴影映射 - LearnOpenGL CN</title>

        <link href="./阴影映射 - LearnOpenGL CN_files/bootstrap-custom.min.css" rel="stylesheet">
        <link href="./阴影映射 - LearnOpenGL CN_files/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="./阴影映射 - LearnOpenGL CN_files/highlight.css">
        <link href="./阴影映射 - LearnOpenGL CN_files/base.css" rel="stylesheet">
        <link href="./阴影映射 - LearnOpenGL CN_files/style.css" rel="stylesheet">
        <link href="./阴影映射 - LearnOpenGL CN_files/admonition_fix.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script async="" src="./阴影映射 - LearnOpenGL CN_files/analytics.js.download"></script><script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-80323542-1', 'auto');
          ga('send', 'pageview');
        </script>
    <script src="https://learnopengl-cn.disqus.com/embed.js" data-timestamp="1562078045767"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="search" src="./阴影映射 - LearnOpenGL CN_files/search.js.download"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../mkdocs/js/mustache.min.js" src="./阴影映射 - LearnOpenGL CN_files/mustache.min.js.download"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="../../../mkdocs/js/lunr.min.js" src="./阴影映射 - LearnOpenGL CN_files/lunr.min.js.download"></script><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="text" src="./阴影映射 - LearnOpenGL CN_files/text.js.download"></script><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.1') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>

    <body style=""><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li>
                    <a href="https://learnopengl-cn.github.io/">主页</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#" class="dropdown-toggle" data-toggle="dropdown">目录 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li>
    <a href="https://learnopengl-cn.github.io/intro/">简介</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">入门</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/">OpenGL</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/">创建窗口</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">你好，窗口</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">你好，三角形</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">着色器</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/">纹理</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">变换</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">摄像机</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/10%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">光照</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/01%20Colors/">颜色</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/">基础光照</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/03%20Materials/">材质</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/04%20Lighting%20maps/">光照贴图</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/">投光物</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/06%20Multiple%20lights/">多光源</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/02%20Lighting/07%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">模型加载</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/03%20Model%20Loading/01%20Assimp/">Assimp</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/03%20Model%20Loading/02%20Mesh/">网格</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/03%20Model%20Loading/03%20Model/">模型</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级OpenGL</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/">深度测试</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/02%20Stencil%20testing/">模板测试</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/03%20Blending/">混合</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/04%20Face%20culling/">面剔除</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/05%20Framebuffers/">帧缓冲</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/06%20Cubemaps/">立方体贴图</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/07%20Advanced%20Data/">高级数据</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/08%20Advanced%20GLSL/">高级GLSL</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/09%20Geometry%20Shader/">几何着色器</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/10%20Instancing/">实例化</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/11%20Anti%20Aliasing/">抗锯齿</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级光照</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/01%20Advanced%20Lighting/">高级光照</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/">Gamma校正</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">阴影</a>
    <ul class="dropdown-menu">
        
            
<li class="active">
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/">阴影映射</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/02%20Point%20Shadows/">点阴影</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/03%20CSM/">CSM</a>
</li>

        
    </ul>
  </li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">法线贴图</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/05%20Parallax%20Mapping/">视差贴图</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/">HDR</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/">泛光</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/">延迟着色法</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/09%20SSAO/">SSAO</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">PBR</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">理论</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/">光照</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">IBL</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">漫反射辐照</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/">镜面IBL</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">实战</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/01%20Debugging/">调试</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/02%20Text%20Rendering/">文本渲染</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2D游戏</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/01%20Breakout/">Breakout</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/02%20Setting%20up/">准备工作</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/03%20Rendering%20Sprites/">渲染精灵</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/04%20Levels/">关卡</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">碰撞</a>
    <ul class="dropdown-menu">
        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/05%20Collisions/01%20Ball/">球</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/05%20Collisions/02%20Collision%20detection/">碰撞检测</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/05%20Collisions/03%20Collision%20resolution/">碰撞处理</a>
</li>

        
    </ul>
  </li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/06%20Particles/">粒子</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/07%20Postprocessing/">后期处理</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/08%20Powerups/">道具</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/09%20Audio/">音效</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/10%20Render%20Text/">渲染文本</a>
</li>

        
            
<li>
    <a href="https://learnopengl-cn.github.io/06%20In%20Practice/2D-Game/11%20Final%20thoughts/">结语</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
<li>
    <a href="https://learnopengl-cn.github.io/legacy/">历史存档</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li>
                    <a href="https://learnopengl-cn.github.io/code_repo/">代码仓库</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> 搜索
                    </a>
                </li>
                <li>
                    <a rel="next" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/">
                        <i class="fa fa-arrow-left"></i> 上一节
                    </a>
                </li>
                <li>
                    <a rel="prev" href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/02%20Point%20Shadows/">
                        下一节 <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/LearnOpenGL-CN/LearnOpenGL-CN">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
                <li>
                    <a href="https://www.paypal.me/learnopengl/">
                            <img class="paypal" src="./阴影映射 - LearnOpenGL CN_files/paypal_logo.png" alt="">
                        支持原作者
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main"><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_1">阴影映射</a></li>
        
            <li class=""><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_2">阴影映射</a></li>
        
            <li class="active"><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_3">深度贴图</a></li>
        
            <li><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_6">渲染阴影</a></li>
        
            <li><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_7">改进阴影贴图</a></li>
        
            <li><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#pcf">PCF</a></li>
        
            <li><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/#_11">附加资源</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="_1">阴影映射</h1>
<table class="table table-striped table-hover">
<thead>
<tr>
<th>原文</th>
<th><a href="http://learnopengl.com/#!Advanced-Lighting/Shadows/Shadow-Mapping">Shadow Mapping</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>作者</td>
<td>JoeyDeVries</td>
</tr>
<tr>
<td>翻译</td>
<td><a href="http://bullteacher.com/">Django</a></td>
</tr>
<tr>
<td>校对</td>
<td>gjy_1992</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>本节暂未进行完全的重写，错误可能会很多。如果可能的话，请对照原文进行阅读。如果有报告本节的错误，将会延迟至重写之后进行处理。</p>
</div>
<p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系。场景和物体的深度感因此能够得到极大提升，下图展示了有阴影和没有阴影的情况下的不同：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_with_without.png"></p>
<p>你可以看到，有阴影的时候你能更容易地区分出物体之间的位置关系，例如，当使用阴影的时候浮在地板上的立方体的事实更加清晰。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的弱点和不足，这点我们必须要考虑到。</p>
<p>视频游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法（比如 <a href="http://learnopengl.com/#!Advanced-Lighting/Shadows/Point-Shadows">Omnidirectional Shadow Maps</a>和 <a href="http://learnopengl.com/#!Advanced-Lighting/Shadows/CSM">Cascaded Shadow Maps</a>）。</p>
<h2 id="_2">阴影映射</h2>
<p>阴影映射(Shadow Mapping)背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_theory.png"></p>
<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片元上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线。我们所使用的是非常熟悉的东西：深度缓冲。</p>
<p>你可能记得在<a href="http://learnopengl.com/#!Advanced-OpenGL/Depth-testing">深度测试</a>教程中，在深度缓冲里的一个值是摄像机视角下，对应于一个片元的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中会怎样？通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片元了。我们管储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_theory_spaces.png"></p>
<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片元是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 0.909em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.696em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.496em, 1000.7em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">T</script>变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>定向光并没有位置，因为它被规定为无穷远。然而，为了实现阴影贴图，我们得从一个光的透视图渲染场景，这样就得在光的方向的某一点上渲染场景。</p>
</div>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-4" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-5"><span class="texatom" id="MathJax-Span-6"><span class="mrow" id="MathJax-Span-7"><span class="munderover" id="MathJax-Span-8"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-9" style="color: red;"><span class="mrow" id="MathJax-Span-10" style="color: red;"><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-2">\bar{\color{red}{P}}</script>处的片元，需要决定它是否在阴影中。我们先得使用<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-13" style="width: 0.909em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.696em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.496em, 1000.7em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-14"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-3">T</script>把<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-16" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-17"><span class="texatom" id="MathJax-Span-18"><span class="mrow" id="MathJax-Span-19"><span class="munderover" id="MathJax-Span-20"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-21" style="color: red;"><span class="mrow" id="MathJax-Span-22" style="color: red;"><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-24" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4">\bar{\color{red}{P}}</script>变换到光源的坐标空间里。既然点<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-25" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-26"><span class="texatom" id="MathJax-Span-27"><span class="mrow" id="MathJax-Span-28"><span class="munderover" id="MathJax-Span-29"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-30" style="color: red;"><span class="mrow" id="MathJax-Span-31" style="color: red;"><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-33" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-5">\bar{\color{red}{P}}</script>是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-34" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-35"><span class="texatom" id="MathJax-Span-36"><span class="mrow" id="MathJax-Span-37"><span class="munderover" id="MathJax-Span-38"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-39" style="color: red;"><span class="mrow" id="MathJax-Span-40" style="color: red;"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-6">\bar{\color{red}{P}}</script>在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;green&quot;&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-43" style="width: 0.963em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.749em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.283em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-44"><span class="texatom" id="MathJax-Span-45"><span class="mrow" id="MathJax-Span-46"><span class="munderover" id="MathJax-Span-47"><span style="display: inline-block; position: relative; width: 0.749em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-48" style="color: green;"><span class="mrow" id="MathJax-Span-49" style="color: green;"><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math-italic; color: green;">C<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.317em; left: 0.269em;"><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.27em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="green"><mi>C</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-7">\bar{\color{green}{C}}</script>，最近的深度是0.4。因为索引深度贴图的结果是一个小于点<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-52" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-53"><span class="texatom" id="MathJax-Span-54"><span class="mrow" id="MathJax-Span-55"><span class="munderover" id="MathJax-Span-56"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-57" style="color: red;"><span class="mrow" id="MathJax-Span-58" style="color: red;"><span class="mi" id="MathJax-Span-59" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-60" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-8">\bar{\color{red}{P}}</script>的深度，我们可以断定<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mover&gt;&lt;mstyle mathcolor=&quot;red&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;mo stretchy=&quot;false&quot;&gt;&amp;#x00AF;&lt;/mo&gt;&lt;/mover&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-61" style="width: 1.016em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.336em, 1000.75em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-62"><span class="texatom" id="MathJax-Span-63"><span class="mrow" id="MathJax-Span-64"><span class="munderover" id="MathJax-Span-65"><span style="display: inline-block; position: relative; width: 0.803em; height: 0px;"><span style="position: absolute; clip: rect(3.149em, 1000.75em, 4.163em, -999.997em); top: -3.997em; left: 0em;"><span class="mstyle" id="MathJax-Span-66" style="color: red;"><span class="mrow" id="MathJax-Span-67" style="color: red;"><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Math-italic; color: red;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span><span style="position: absolute; clip: rect(3.256em, 1000.43em, 3.629em, -999.997em); top: -4.264em; left: 0.323em;"><span class="mo" id="MathJax-Span-69" style="font-family: MathJax_Main;">¯</span><span style="display: inline-block; width: 0px; height: 4.003em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.203em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mover><mstyle mathcolor="red"><mi>P</mi></mstyle><mo stretchy="false">¯</mo></mover></mrow></math></span></span><script type="math/tex" id="MathJax-Element-9">\bar{\color{red}{P}}</script>被挡住了，它在阴影中了。</p>
<p>深度映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片元是否在阴影之中。听起来有点复杂，但随着我们一步一步地讲解这个技术，就能理解了。</p>
<h2 id="_3">深度贴图</h2>
<p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</p>
<p>首先，我们要为渲染的深度贴图创建一个帧缓冲对象：</p>
<pre><code class="c++ hljs cpp">GLuint depthMapFBO;
glGenFramebuffers(<span class="hljs-number">1</span>, &amp;depthMapFBO);
</code></pre>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">const</span> GLuint SHADOW_WIDTH = <span class="hljs-number">1024</span>, SHADOW_HEIGHT = <span class="hljs-number">1024</span>;

GLuint depthMap;
glGenTextures(<span class="hljs-number">1</span>, &amp;depthMap);
glBindTexture(GL_TEXTURE_2D, depthMap);
glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, 
             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); 
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</code></pre>

<p>生成深度贴图不太复杂。因为我们只关心深度值，我们要把纹理格式指定为GL_DEPTH_COMPONENT。我们还要把纹理的高宽设置为1024：这是深度贴图的解析度。</p>
<p>把我们把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<pre><code class="c++ hljs cpp">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="hljs-number">0</span>);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);
</code></pre>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。然而帧缓冲对象不是完全不包含颜色缓冲的，所以我们需要显式告诉OpenGL我们不适用任何颜色数据进行渲染。我们通过将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE来做这件事。</p>
<p>合理配置将深度值渲染到纹理的帧缓冲后，我们就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-comment">// 1. 首选渲染深度贴图</span>
glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
    glClear(GL_DEPTH_BUFFER_BIT);
    ConfigureShaderAndMatrices();
    RenderScene();
glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 2. 像往常一样渲染场景，但这次使用深度贴图</span>
glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
ConfigureShaderAndMatrices();
glBindTexture(GL_TEXTURE_2D, depthMap);
RenderScene();
</code></pre>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为阴影贴图经常和我们原来渲染的场景（通常是窗口解析度）有着不同的解析度，我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h3 id="_4">光源空间的变换</h3>
<p>前面那段代码中一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<pre><code class="c++ hljs cpp">GLfloat near_plane = <span class="hljs-number">1.0f</span>, far_plane = <span class="hljs-number">7.5f</span>;
glm::mat4 lightProjection = glm::ortho(-<span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>, -<span class="hljs-number">10.0f</span>, <span class="hljs-number">10.0f</span>, near_plane, far_plane);
</code></pre>

<p>这里有个本节教程的demo场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片元不在深度贴图中时，它们就不会产生阴影。</p>
<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<pre><code class="c++ hljs cpp">glm::mat4 lightView = glm::lookAt(glm::vec(-<span class="hljs-number">2.0f</span>, <span class="hljs-number">4.0f</span>, -<span class="hljs-number">1.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>), glm::vec3(<span class="hljs-number">1.0</span>));
</code></pre>

<p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>
<pre><code class="c++ hljs cpp">glm::mat4 lightSpaceMatrix = lightProjection * lightView;
</code></pre>

<p>这个lightSpaceMatrix正是前面我们称为<span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-70" style="width: 0.909em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.696em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.496em, 1000.7em, 2.509em, -999.997em); top: -2.344em; left: 0em;"><span class="mrow" id="MathJax-Span-71"><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math-italic;">T<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.109em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.349em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.063em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-10">T</script>的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片元计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>
<h3 id="_5">渲染至深度贴图</h3>
<p>当我们以光的透视图进行场景渲染的时候，我们会用一个比较简单的着色器，这个着色器除了把顶点变换到光空间以外，不会做得更多了。这个简单的着色器叫做<code>simpleDepthShader</code>，就是使用下面的这个着色器：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>
layout (location = <span class="hljs-number">0</span>) in vec3 position;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    gl_Position = lightSpaceMatrix * model * vec4(position, <span class="hljs-number">1.0f</span>);
}
</code></pre>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。</p>
<p>由于我们没有颜色缓冲，最后的片元不需要任何处理，所以我们可以简单地使用一个空像素着色器：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{             
    <span class="hljs-comment">// gl_FragDepth = gl_FragCoord.z;</span>
}
</code></pre>

<p>这个空像素着色器什么也不干，运行完后，深度缓冲会被更新。我们可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。</p>
<p>渲染深度缓冲现在成了：</p>
<pre><code class="c++ hljs cpp">simpleDepthShader.Use();
glUniformMatrix4fv(lightSpaceMatrixLocation, <span class="hljs-number">1</span>, GL_FALSE, glm::value_ptr(lightSpaceMatrix));

glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
    glClear(GL_DEPTH_BUFFER_BIT);
    RenderScene(simpleDepthShader);
glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);
</code></pre>

<p>这里的RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。</p>
<p>最后，在光的透视图视角下，很完美地用每个可见片元的最近深度填充了深度缓冲。通过将这个纹理投射到一个2D四边形上（和我们在帧缓冲一节做的后处理过程类似），就能在屏幕上显示出来，我们会获得这样的东西：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_depth_map.png"></p>
<p>将深度贴图渲染到四边形上的像素着色器：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>
out vec4 color;
in vec2 TexCoords;

uniform sampler2D depthMap;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{             
    <span class="hljs-keyword">float</span> depthValue = texture(depthMap, TexCoords).r;
    color = vec4(vec3(depthValue), <span class="hljs-number">1.0</span>);
}
</code></pre>

<p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。本节教程的最后，我们会讨论这些不同之处。</p>
<p>你可以在<a href="http://learnopengl.com/code_viewer.php?code=advanced-lighting/shadow_mapping_depth_map">这里</a>获得把场景渲染成深度贴图的源码。</p>
<h2 id="_6">渲染阴影</h2>
<p>正确地生成深度贴图以后我们就可以开始生成阴影了。这段代码在像素着色器中执行，用来检验一个片元是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>
layout (location = <span class="hljs-number">0</span>) in vec3 position;
layout (location = <span class="hljs-number">1</span>) in vec3 normal;
layout (location = <span class="hljs-number">2</span>) in vec2 texCoords;

out vec2 TexCoords;

out VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;
} vs_out;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;
uniform mat4 lightSpaceMatrix;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    gl_Position = projection * view * model * vec4(position, <span class="hljs-number">1.0f</span>);
    vs_out.FragPos = vec3(model * vec4(position, <span class="hljs-number">1.0</span>));
    vs_out.Normal = transpose(inverse(mat3(model))) * normal;
    vs_out.TexCoords = texCoords;
    vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, <span class="hljs-number">1.0</span>);
}
</code></pre>

<p>这儿的新的地方是FragPosLightSpace这个输出向量。我们用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给像素着色器。</p>
<p>像素着色器使用Blinn-Phong光照模型渲染场景。我们接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的（由于散射），我们把ambient分量从乘法中剔除。</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>
out vec4 FragColor;

in VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;
} fs_in;

uniform sampler2D diffuseTexture;
uniform sampler2D shadowMap;

uniform vec3 lightPos;
uniform vec3 viewPos;

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span>
</span>{
    [...]
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{           
    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightColor = vec3(<span class="hljs-number">1.0</span>);
    <span class="hljs-comment">// Ambient</span>
    vec3 ambient = <span class="hljs-number">0.15</span> * color;
    <span class="hljs-comment">// Diffuse</span>
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    <span class="hljs-keyword">float</span> diff = max(dot(lightDir, normal), <span class="hljs-number">0.0</span>);
    vec3 diffuse = diff * lightColor;
    <span class="hljs-comment">// Specular</span>
    vec3 viewDir = normalize(viewPos - fs_in.FragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    <span class="hljs-keyword">float</span> spec = <span class="hljs-number">0.0</span>;
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    spec = <span class="hljs-built_in">pow</span>(max(dot(normal, halfwayDir), <span class="hljs-number">0.0</span>), <span class="hljs-number">64.0</span>);
    vec3 specular = spec * lightColor;    
    <span class="hljs-comment">// 计算阴影</span>
    <span class="hljs-keyword">float</span> shadow = ShadowCalculation(fs_in.FragPosLightSpace);       
    vec3 lighting = (ambient + (<span class="hljs-number">1.0</span> - shadow) * (diffuse + specular)) * color;    

    FragColor = vec4(lighting, <span class="hljs-number">1.0f</span>);
}
</code></pre>

<p>像素着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个shadowCalculation函数，用它计算阴影。像素着色器的最后，我们我们把diffuse和specular乘以(1-阴影元素)，这表示这个片元有多大成分不在阴影中。这个像素着色器还需要两个额外输入，一个是光空间的片元位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片元是否在阴影中，把光空间片元位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这要将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到像素着色器里，我们必须自己做透视除法：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span>
</span>{
    <span class="hljs-comment">// 执行透视除法</span>
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    [...]
}
</code></pre>

<p>返回了片元在光空间的-1到1的范围。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行。</p>
</div>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以我们将NDC坐标变换为0到1的范围：
（译者注：这里的意思是，上面的projCoords的xyz分量都是[-1,1]（下面会指出这对于远平面之类的点才成立），而为了和深度贴图的深度相比较，z分量需要变换到[0,1]；为了作为从深度贴图中采样的坐标，xy分量也需要变换到[0,1]。所以整个projCoords向量都需要变换到[0,1]范围。）</p>
<pre><code class="c++ hljs cpp">projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;
</code></pre>

<p>有了这些投影坐标，我们就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r;
</code></pre>

<p>为了得到片元的当前深度，我们简单获取投影向量的z坐标，它等于来自光的透视视角的片元的深度。</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> currentDepth = projCoords.z;
</code></pre>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片元就在阴影中。</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;
</code></pre>

<p>完整的shadowCalculation函数是这样的：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span>
</span>{
    <span class="hljs-comment">// 执行透视除法</span>
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    <span class="hljs-comment">// 变换到[0,1]的范围</span>
    projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;
    <span class="hljs-comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span>
    <span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r; 
    <span class="hljs-comment">// 取得当前片元在光源视角下的深度</span>
    <span class="hljs-keyword">float</span> currentDepth = projCoords.z;
    <span class="hljs-comment">// 检查当前片元是否在阴影中</span>
    <span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">return</span> shadow;
}
</code></pre>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_shadows.png"></p>
<p>如果你做对了，你会看到地板和上有立方体的阴影。你可以从这里找到demo程序的<a href="http://learnopengl.com/code_viewer.php?code=advanced-lighting/shadow_mapping_shadows">源码</a>。</p>
<h2 id="_7">改进阴影贴图</h2>
<p>我们试图让阴影映射工作，但是你也看到了，阴影映射还是有点不真实，我们修复它才能获得更好的效果，这是下面的部分所关注的焦点。</p>
<h3 id="_8">阴影失真</h3>
<p>前面的图片中明显有不对的地方。放大看会发现明显的线条样式：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_acne.png"></p>
<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真(Shadow Acne)</strong>，下图解释了成因：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_acne_diagram.png"></p>
<p>因为阴影贴图受限于解析度，在距离光源比较远的情况下，多个片元可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片元从同一个深度值进行采样。</p>
<p>虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片元就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片元被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片元就不会被错误地认为在表面之下了。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_acne_bias.png"></p>
<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。我们可以这样实现这个偏移：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> bias = <span class="hljs-number">0.005</span>;
<span class="hljs-keyword">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;
</code></pre>

<p>一个0.005的偏移就能帮到很大的忙，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量：使用点乘：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> bias = max(<span class="hljs-number">0.05</span> * (<span class="hljs-number">1.0</span> - dot(normal, lightDir)), <span class="hljs-number">0.005</span>);
</code></pre>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_with_bias.png"></p>
<p>选用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被移除的问题。</p>
<h3 id="_9">悬浮</h3>
<p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_peter_panning.png"></p>
<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来轻轻悬浮在表面之上（译注Peter Pan就是童话彼得潘，而panning有平移、悬浮之意，而且彼得潘是个会飞的男孩…）。我们可以使用一个叫技巧解决大部分的Peter panning问题：当渲染深度贴图时候使用正面剔除（front face culling）你也许记得在面剔除教程中OpenGL默认是背面剔除。我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_culling.png"></p>
<p>为了修复peter游移，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<pre><code class="c++ hljs cpp">glCullFace(GL_FRONT);
RenderSceneToDepthMap();
glCullFace(GL_BACK); <span class="hljs-comment">// 不要忘记设回原先的culling face</span>
</code></pre>

<p>这十分有效地解决了peter panning的问题，但只针对实体物体，内部不会对外开口。我们的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果有人打算使用这个技巧解决peter panning必须考虑到只有剔除物体的正面才有意义。</p>
<p>另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免peter panning。</p>
<h3 id="_10">采样过多</h3>
<p>无论你喜不喜欢还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_outside_frustum.png"></p>
<p>你可以在图中看到，光照有一个区域，超出该区域就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是我们之前将深度贴图的环绕方式设置成了GL_REPEAT。</p>
<p>我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<pre><code class="c++ hljs cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
GLfloat borderColor[] = { <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
</code></pre>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。结果看起来会更真实：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_clamp_edge.png"></p>
<p>仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>
<p>当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为我们把坐标的z元素和深度贴图的值进行了对比；它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span>
</span>{
    [...]
    <span class="hljs-keyword">if</span>(projCoords.z &gt; <span class="hljs-number">1.0</span>)
        shadow = <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">return</span> shadow;
}
</code></pre>

<p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，我们最终会得到下面我们所追求的效果：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_over_sampling_fixed.png"></p>
<p>这些结果意味着，只有在深度贴图范围以内的被投影的fragment坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，就会比我们之前的那个明显的黑色区域效果更真实。</p>
<h2 id="pcf">PCF</h2>
<p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对解析度的依赖很快变得很明显。</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_zoom.png"></p>
<p>因为深度贴图有一个固定的解析度，多个片元对应于一个纹理像素。结果就是多个片元会从深度贴图的同一个深度值进行采样，这几个片元便得到的是同一个阴影，这就会产生锯齿边。</p>
<p>你可以通过增加深度贴图解析度的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个（并不完整的）解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<pre><code class="c++ hljs cpp"><span class="hljs-keyword">float</span> shadow = <span class="hljs-number">0.0</span>;
vec2 texelSize = <span class="hljs-number">1.0</span> / textureSize(shadowMap, <span class="hljs-number">0</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">1</span>; ++x)
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = -<span class="hljs-number">1</span>; y &lt;= <span class="hljs-number">1</span>; ++y)
    {
        <span class="hljs-keyword">float</span> pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
        shadow += currentDepth - bias &gt; pcfDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;        
    }    
}
shadow /= <span class="hljs-number">9.0</span>;
</code></pre>

<p>这个textureSize返回一个给定采样器纹理的0级mipmap的vec2类型的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里我们采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。</p>
<p>使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_soft_shadows.png"></p>
<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图解析度的不真实感，但通常对于大多数应用来说效果已经很好了。</p>
<p>你可以从<a href="http://learnopengl.com/code_viewer.php?code=advanced-lighting/shadow_mapping">这里</a>找到这个例子的全部源码和第二个阶段的<a href="http://learnopengl.com/code_viewer.php?code=advanced-lighting/shadow_mapping&amp;type=vertex">顶点</a>和<a href="http://learnopengl.com/code_viewer.php?code=advanced-lighting/shadow_mapping&amp;type=fragment">片段</a>着色器。</p>
<p>实际上PCF还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，但处于本章内容长度考虑，我们将留在以后讨论。</p>
<h3 id="vs">正交 vs 投影</h3>
<p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线/光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<p><img alt="" src="./阴影映射 - LearnOpenGL CN_files/shadow_mapping_projection.png"></p>
<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围接近于近平面。为了可以像使用正交投影一样合适的观察到深度值，你必须先讲过非线性深度值转变为线性的，我们在深度测试教程中已经讨论过。</p>
<pre><code class="c++ hljs cpp"><span class="hljs-preprocessor">#version 330 core</span>
out vec4 color;
in vec2 TexCoords;

uniform sampler2D depthMap;
uniform <span class="hljs-keyword">float</span> near_plane;
uniform <span class="hljs-keyword">float</span> far_plane;

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">LinearizeDepth</span><span class="hljs-params">(<span class="hljs-keyword">float</span> depth)</span>
</span>{
    <span class="hljs-keyword">float</span> z = depth * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>; <span class="hljs-comment">// Back to NDC </span>
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{             
    <span class="hljs-keyword">float</span> depthValue = texture(depthMap, TexCoords).r;
    color = vec4(vec3(LinearizeDepth(depthValue) / far_plane), <span class="hljs-number">1.0</span>); <span class="hljs-comment">// perspective</span>
    <span class="hljs-comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span>
}
</code></pre>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h2 id="_11">附加资源</h2>
<ul>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial 16 : Shadow mapping</a>：提供的类似的阴影映射教程，里面有一些额外的解释。</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping – Part 1：ogldev</a>：提供的另一个阴影映射教程。</li>
<li><a href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a>：的一个第三方YouTube视频教程，里面解释了阴影映射及其实现。</li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324%28v=vs.85%29.aspx">Common Techniques to Improve Shadow Depth Maps</a>：微软的一篇好文章，其中理出了很多提升阴影贴图质量的技术。</li>
</ul>

<div id="disqus_thread"></div>
<script>
    (function() {
        var d = document, s = d.createElement('script');
        
        s.src = '//learnopengl-cn.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>请启用JavaScript以浏览<a href="https://disqus.com/?ref_noscript" rel="nofollow">Disqus评论。</a></noscript></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Powered by <a href="http://www.mkdocs.org/">MkDocs</a> and <a href="http://bootswatch.com/yeti/">Yeti</a></center>
        </footer>

        <script src="./阴影映射 - LearnOpenGL CN_files/jquery-1.10.2.min.js.download"></script>
        <script src="./阴影映射 - LearnOpenGL CN_files/bootstrap-3.0.3.min.js.download"></script>
        <script src="./阴影映射 - LearnOpenGL CN_files/highlight.pack.js.download"></script>
        <script>var base_url = '../../..';</script>
        <script data-main="../../../mkdocs/js/search.js" src="./阴影映射 - LearnOpenGL CN_files/require.js.download"></script>
        <script src="./阴影映射 - LearnOpenGL CN_files/base.js.download"></script>
        <script src="./阴影映射 - LearnOpenGL CN_files/MathJax.js.download"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">×</span><span class="sr-only">关闭</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">搜索</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            请在下面输入你要搜索的文本（仅支持英文）：
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="搜索..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    
<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Main, sans-serif;"></div></div></body></html>